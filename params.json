{"name":"On working with The Virtual Brain ","tagline":"and some non virtual thoughts about Google Summer of Code 2014.","body":"### What is this about? \r\n\r\nHi all, my name is Robert Parcus and I'm a CS student\r\nfrom UNIPG (Italy). I'm moving to Hong Kong this September to further my studies\r\nand my plan for the Summer of 2014 was to participate in this year's [Google\r\nSummer Of Code](https://www.google-melange.com/gsoc/homepage/google/gsoc2014).\r\n\r\nGladly, I was accepted as a student in this amazing project and here I would\r\nlike to spend a few words about the whole experience. Going from the application\r\nphase up to the finishing days. I hope you will enjoy the journey as much as I\r\ndid.\r\n\r\n### The Application Phase:\r\nAfter browsing the list of accepted organizations, I quick\r\n\r\n### Volumetric Time series visualizer for TVB and updating other visualization tools\r\n\r\nThis was the final title of my proposal. From the Google-melange website:\r\n>**Organization:** International Neuroinformatics Coordinating Facility\r\n\r\n>**Assigned mentors:** Lia Domide, Paula Sanz-Leon\r\n\r\n>**Short description:** The main goal of this proposal is to implement a time-\r\nseries visualizer for 4D data in TVB, which would enable users to work with\r\ntheir functional MRI data directly from the browser. Then I will work on\r\nrewriting some of the visualizers that are currently implemented using\r\nMatplotLib and MPLH5, backed with web-friendly tools.\r\n\r\nThe proposal itself was much bigger and specific than this. The whole\r\napplication phase was already a big challenge by itself. It was my first time\r\nplanning for  a project this big and I learned a lot during the process. A big\r\nhelp came from my mentors who always had good suggestions ready for me and I\r\ncan't stress enough how much a good advice from your mentor can help you in a\r\ntricky situation.\r\n\r\n\r\n### Technical aspects\r\n![The Visulizer Prototype](/images/tvbPost/first.png \"The Visulizer Prototype\")\r\n\r\nWe decided to work on an already implemented prototype. The basic features to\r\ndisplay the slices were already in place but the visualizer was missing its\r\nplayback  functionalities.\r\n\r\nAlso, since fMRI data can be huge, a buffering mechanism was necessary in order\r\nto load the required information and display it as fast as possible on the\r\nbrowser.\r\n\r\nAt first, I decided to give our visualizer a real user interface, so that I\r\ncould test it directly as a user would do, without having to rely only on the\r\nconsole. The UI would also help display some information about the data being\r\nvisualized, like selected time point and coordinates. Moreover, I tried to\r\nresize the quadrants and give each one of them a margin.\r\n\r\nAfter playing around with the quadrants settings and using jQuery UI to create\r\nthe user interface I had something very basic, like this:\r\n![First UI](/images/tvbPost/second.png \"First UI\")\r\n\r\nNow, for the hard part, it was time to focus on the buffering and the playback\r\nfeatures.\r\n\r\nMy first attempt was to load everything in memory, but soon it was clear that\r\nthis was not a realistic approach. A compressed fMRI file can easily occupy\r\nhundreds of Megabytes, hence loaded, uncompressed data could easily surpass the\r\nGigabyte mark.\r\n\r\nFor example, we had a 91x109x91 voxels test set and it was 177 frames long. This\r\nmakes for a floating point array with 159765333 elements.\r\nSuch a big javascript array is just an easy way to crash your browser.\r\n\r\nOn the other hand, a purely lazy approach was also a bad solution: To query for\r\na single frame, wait for the server to prepare it, receive the json data and\r\nparse it was either too slow or an overall waste of bandwidth, because of the\r\noverhead of requesting only one frame at a time. Also, even if AJAX calls can be\r\nmade asynchronously, the playback and UI would all freeze while waiting for the\r\nparsing operations.\r\n\r\nTo avoid blocking the main thread we used webworkes for parsing the json. An in-\r\nline wrapper was used so that we didn't need to use a separate file for the\r\nwebworker code.\r\n\r\n```javascript\r\nfunction inlineWebWorkerWrapper(workerBody){\r\n    var retBlob = URL.createObjectURL(\r\n        new Blob([\r\n            '(',\r\n                workerBody.toString(),\r\n            ')()' ],\r\n        { type: 'application/javascript' }\r\n        )\r\n    );\r\n    return retBlob;\r\n}\r\n```\r\nWhile the parsing function was similar to:\r\n```javascript\r\nvar parserBlob = inlineWebWorkerWrapper(\r\n            function(){\r\n                self.addEventListener( 'message', function (e){\r\n                    // Parse JSON, send it to main thread, close the worker\r\n                    self.postMessage(JSON.parse(e.data));\r\n                    self.close();\r\n                }, false );\r\n            }\r\n        );\r\n\r\nfunction parseAsync(data, callback){\r\n    var worker;\r\n    var json;\r\n    if( window.Worker ){\r\n        worker = new Worker( parserBlob );\r\n        worker.addEventListener( 'message', function (e){\r\n            json = e.data;\r\n            callback( json );\r\n        }, false);\r\n        worker.postMessage( data );\r\n    }\r\n    else{\r\n        json = JSON.parse( data );\r\n        callback( json );\r\n    }\r\n}\r\n```\r\n\r\nIt is important to remember that this approach **will not** speed up the parsing\r\nitself (it may even delay it). Its only benefit is that the main thread will\r\nnever freeze while waiting for the parsing to happen and during playback this\r\nis exactly what we need.\r\n\r\nWith the parsing problem solved, the next thing was buffering.\r\n\r\nThe visualizer checks the selected voxel and asynchronously queries the server\r\nfor batches of frames of the three visible planes only. If our data is composed\r\nof n sized MRI \"cubes\", this approach reduces the spatial complexity of each\r\nframe from O(n^3) to O(n^2).\r\n\r\nIf the user clicks the planes to navigate in space, we halt the buffering of\r\nfuture frames and synchronously load the complete cube data for that time point.\r\nA little delay was expected in this cases but we noticed that it consisted of a\r\nnegligible wait for average resolution data. As soon as the user stops picking,\r\nwe can resume playback again, together with the buffering of future data based\r\non the new selected voxel.\r\n\r\nCoupled with the buffering system, a safety procedure was put in place \r\nto keep the memory footprint always under a certain threshold.\r\n\r\n### Time Series Fragment Visualizer\r\n\r\nAfter the completion of the Volumetric Time Series Visualizer, the plan was to\r\nwork a little on many other visualizers on The Virtual Brain. Talking with my mentors\r\n@liadomide and @paulsz we decided that if I could work on a complete\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}